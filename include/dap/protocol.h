// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated with protocol_gen.go -- do not edit this file.
//   go run scripts/protocol_gen/protocol_gen.go

#ifndef dap_protocol_h
#define dap_protocol_h

#include "optional.h"
#include "typeinfo.h"
#include "typeof.h"
#include "variant.h"

#include <string>
#include <type_traits>
#include <vector>

namespace dap {

struct Request {};
struct Response {};
struct Event {};

// Response to 'attach' request. This is just an acknowledgement, so no body
// field is required.
struct AttachResponse : public Response {
  AttachResponse();
  ~AttachResponse();
};

DAP_DECLARE_STRUCT_TYPEINFO(AttachResponse);

// The attach request is sent from the client to the debug adapter to attach to
// a debuggee that is already running. Since attaching is debugger/runtime
// specific, the arguments for this request are not part of this specification.
struct AttachRequest : public Request {
  using Response = AttachResponse;

  AttachRequest();
  ~AttachRequest();

  // Optional data from the previous, restarted session.
  // The data is sent as the 'restart' attribute of the 'terminated' event.
  // The client should leave the data intact.
  optional<variant<array<any>, boolean, integer, null, number, object, string>>
      restart;
};

DAP_DECLARE_STRUCT_TYPEINFO(AttachRequest);

// Names of checksum algorithms that may be supported by a debug adapter.
struct ChecksumAlgorithm {
  ChecksumAlgorithm();
  ~ChecksumAlgorithm();
};

DAP_DECLARE_STRUCT_TYPEINFO(ChecksumAlgorithm);

// The checksum of an item calculated by the specified algorithm.
struct Checksum {
  Checksum();
  ~Checksum();

  // The algorithm used to calculate this checksum.
  ChecksumAlgorithm algorithm;
  // Value of the checksum.
  string checksum;
};

DAP_DECLARE_STRUCT_TYPEINFO(Checksum);

// A Source is a descriptor for source code. It is returned from the debug
// adapter as part of a StackFrame and it is used by clients when specifying
// breakpoints.
struct Source {
  Source();
  ~Source();

  // Optional data that a debug adapter might want to loop through the client.
  // The client should leave the data intact and persist it across sessions. The
  // client should not interpret the data.
  optional<variant<array<any>, boolean, integer, null, number, object, string>>
      adapterData;
  // The checksums associated with this file.
  optional<array<Checksum>> checksums;
  // The short name of the source. Every source returned from the debug adapter
  // has a name. When sending a source to the debug adapter this name is
  // optional.
  optional<string> name;
  // The (optional) origin of this source: possible values 'internal module',
  // 'inlined content from source map', etc.
  optional<string> origin;
  // The path of the source to be shown in the UI. It is only used to locate and
  // load the content of the source if no sourceReference is specified (or its
  // value is 0).
  optional<string> path;
  // An optional hint for how to present the source in the UI. A value of
  // 'deemphasize' can be used to indicate that the source is not available or
  // that it is skipped on stepping.
  //
  // Must be one of the following enumeration values:
  // 'normal', 'emphasize', 'deemphasize'
  optional<string> presentationHint;
  // If sourceReference > 0 the contents of the source must be retrieved through
  // the SourceRequest (even if a path is specified). A sourceReference is only
  // valid for a session, so it must not be used to persist a source. The value
  // should be less than or equal to 2147483647 (2^31 - 1).
  optional<integer> sourceReference;
  // An optional list of sources that are related to this source. These may be
  // the source that generated this source.
  optional<array<Source>> sources;
};

DAP_DECLARE_STRUCT_TYPEINFO(Source);

// Information about a Breakpoint created in setBreakpoints or
// setFunctionBreakpoints.
struct Breakpoint {
  Breakpoint();
  ~Breakpoint();

  // An optional start column of the actual range covered by the breakpoint.
  optional<integer> column;
  // An optional end column of the actual range covered by the breakpoint. If no
  // end line is given, then the end column is assumed to be in the start line.
  optional<integer> endColumn;
  // An optional end line of the actual range covered by the breakpoint.
  optional<integer> endLine;
  // An optional identifier for the breakpoint. It is needed if breakpoint
  // events are used to update or remove breakpoints.
  optional<integer> id;
  // The start line of the actual range covered by the breakpoint.
  optional<integer> line;
  // An optional message about the state of the breakpoint. This is shown to the
  // user and can be used to explain why a breakpoint could not be verified.
  optional<string> message;
  // The source where the breakpoint is located.
  optional<Source> source;
  // If true breakpoint could be set (but not necessarily at the desired
  // location).
  boolean verified;
};

DAP_DECLARE_STRUCT_TYPEINFO(Breakpoint);

// The event indicates that some information about a breakpoint has changed.
struct BreakpointEvent : public Event {
  BreakpointEvent();
  ~BreakpointEvent();

  // The 'id' attribute is used to find the target breakpoint and the other
  // attributes are used as the new values.
  Breakpoint breakpoint;
  // The reason for the event.
  //
  // May be one of the following enumeration values:
  // 'changed', 'new', 'removed'
  string reason;
};

DAP_DECLARE_STRUCT_TYPEINFO(BreakpointEvent);

// Properties of a breakpoint location returned from the 'breakpointLocations'
// request.
struct BreakpointLocation {
  BreakpointLocation();
  ~BreakpointLocation();

  // Optional start column of breakpoint location.
  optional<integer> column;
  // Optional end column of breakpoint location if the location covers a range.
  optional<integer> endColumn;
  // Optional end line of breakpoint location if the location covers a range.
  optional<integer> endLine;
  // Start line of breakpoint location.
  integer line;
};

DAP_DECLARE_STRUCT_TYPEINFO(BreakpointLocation);

// Response to 'breakpointLocations' request.
// Contains possible locations for source breakpoints.
struct BreakpointLocationsResponse : public Response {
  BreakpointLocationsResponse();
  ~BreakpointLocationsResponse();

  // Sorted set of possible breakpoint locations.
  array<BreakpointLocation> breakpoints;
};

DAP_DECLARE_STRUCT_TYPEINFO(BreakpointLocationsResponse);

// The 'breakpointLocations' request returns all possible locations for source
// breakpoints in a given range.
struct BreakpointLocationsRequest : public Request {
  using Response = BreakpointLocationsResponse;

  BreakpointLocationsRequest();
  ~BreakpointLocationsRequest();

  // Optional start column of range to search possible breakpoint locations in.
  // If no start column is given, the first column in the start line is assumed.
  optional<integer> column;
  // Optional end column of range to search possible breakpoint locations in. If
  // no end column is given, then it is assumed to be in the last column of the
  // end line.
  optional<integer> endColumn;
  // Optional end line of range to search possible breakpoint locations in. If
  // no end line is given, then the end line is assumed to be the start line.
  optional<integer> endLine;
  // Start line of range to search possible breakpoint locations in. If only the
  // line is specified, the request returns all possible locations in that line.
  integer line;
  // The source location of the breakpoints; either 'source.path' or
  // 'source.reference' must be specified.
  Source source;
};

DAP_DECLARE_STRUCT_TYPEINFO(BreakpointLocationsRequest);

// Response to 'cancel' request. This is just an acknowledgement, so no body
// field is required.
struct CancelResponse : public Response {
  CancelResponse();
  ~CancelResponse();
};

DAP_DECLARE_STRUCT_TYPEINFO(CancelResponse);

// The 'cancel' request is used by the frontend to indicate that it is no longer
// interested in the result produced by a specific request issued earlier. This
// request has a hint characteristic: a debug adapter can only be expected to
// make a 'best effort' in honouring this request but there are no guarantees.
// The 'cancel' request may return an error if it could not cancel an operation
// but a frontend should refrain from presenting this error to end users. A
// frontend client should only call this request if the capability
// 'supportsCancelRequest' is true. The request that got canceled still needs to
// send a response back. This can either be a normal result ('success' attribute
// true) or an error response ('success' attribute false and the 'message' set
// to 'cancelled'). Returning partial results from a cancelled request is
// possible but please note that a frontend client has no generic way for
// detecting that a response is partial or not.
struct CancelRequest : public Request {
  using Response = CancelResponse;

  CancelRequest();
  ~CancelRequest();

  // The ID (attribute 'seq') of the request to cancel.
  optional<integer> requestId;
};

DAP_DECLARE_STRUCT_TYPEINFO(CancelRequest);

// A ColumnDescriptor specifies what module attribute to show in a column of the
// ModulesView, how to format it, and what the column's label should be. It is
// only used if the underlying UI actually supports this level of customization.
struct ColumnDescriptor {
  ColumnDescriptor();
  ~ColumnDescriptor();

  // Name of the attribute rendered in this column.
  string attributeName;
  // Format to use for the rendered values in this column. TBD how the format
  // strings looks like.
  optional<string> format;
  // Header UI label of column.
  string label;
  // Datatype of values in this column.  Defaults to 'string' if not specified.
  //
  // Must be one of the following enumeration values:
  // 'string', 'number', 'boolean', 'unixTimestampUTC'
  optional<string> type;
  // Width of this column in characters (hint only).
  optional<integer> width;
};

DAP_DECLARE_STRUCT_TYPEINFO(ColumnDescriptor);

// An ExceptionBreakpointsFilter is shown in the UI as an option for configuring
// how exceptions are dealt with.
struct ExceptionBreakpointsFilter {
  ExceptionBreakpointsFilter();
  ~ExceptionBreakpointsFilter();

  // Initial value of the filter. If not specified a value 'false' is assumed.
  optional<boolean> def;
  // The internal ID of the filter. This value is passed to the
  // setExceptionBreakpoints request.
  string filter;
  // The name of the filter. This will be shown in the UI.
  string label;
};

DAP_DECLARE_STRUCT_TYPEINFO(ExceptionBreakpointsFilter);

// Information about the capabilities of a debug adapter.
struct Capabilities {
  Capabilities();
  ~Capabilities();

  // The set of additional module information exposed by the debug adapter.
  optional<array<ColumnDescriptor>> additionalModuleColumns;
  // The set of characters that should trigger completion in a REPL. If not
  // specified, the UI should assume the '.' character.
  optional<array<string>> completionTriggerCharacters;
  // Available filters or options for the setExceptionBreakpoints request.
  optional<array<ExceptionBreakpointsFilter>> exceptionBreakpointFilters;
  // The debug adapter supports the 'terminateDebuggee' attribute on the
  // 'disconnect' request.
  optional<boolean> supportTerminateDebuggee;
  // Checksum algorithms supported by the debug adapter.
  optional<array<ChecksumAlgorithm>> supportedChecksumAlgorithms;
  // The debug adapter supports the 'breakpointLocations' request.
  optional<boolean> supportsBreakpointLocationsRequest;
  // The debug adapter supports the 'cancel' request.
  optional<boolean> supportsCancelRequest;
  // The debug adapter supports the 'completions' request.
  optional<boolean> supportsCompletionsRequest;
  // The debug adapter supports conditional breakpoints.
  optional<boolean> supportsConditionalBreakpoints;
  // The debug adapter supports the 'configurationDone' request.
  optional<boolean> supportsConfigurationDoneRequest;
  // The debug adapter supports data breakpoints.
  optional<boolean> supportsDataBreakpoints;
  // The debug adapter supports the delayed loading of parts of the stack, which
  // requires that both the 'startFrame' and 'levels' arguments and the
  // 'totalFrames' result of the 'StackTrace' request are supported.
  optional<boolean> supportsDelayedStackTraceLoading;
  // The debug adapter supports the 'disassemble' request.
  optional<boolean> supportsDisassembleRequest;
  // The debug adapter supports a (side effect free) evaluate request for data
  // hovers.
  optional<boolean> supportsEvaluateForHovers;
  // The debug adapter supports the 'exceptionInfo' request.
  optional<boolean> supportsExceptionInfoRequest;
  // The debug adapter supports 'exceptionOptions' on the
  // setExceptionBreakpoints request.
  optional<boolean> supportsExceptionOptions;
  // The debug adapter supports function breakpoints.
  optional<boolean> supportsFunctionBreakpoints;
  // The debug adapter supports the 'gotoTargets' request.
  optional<boolean> supportsGotoTargetsRequest;
  // The debug adapter supports breakpoints that break execution after a
  // specified number of hits.
  optional<boolean> supportsHitConditionalBreakpoints;
  // The debug adapter supports the 'loadedSources' request.
  optional<boolean> supportsLoadedSourcesRequest;
  // The debug adapter supports logpoints by interpreting the 'logMessage'
  // attribute of the SourceBreakpoint.
  optional<boolean> supportsLogPoints;
  // The debug adapter supports the 'modules' request.
  optional<boolean> supportsModulesRequest;
  // The debug adapter supports the 'readMemory' request.
  optional<boolean> supportsReadMemoryRequest;
  // The debug adapter supports restarting a frame.
  optional<boolean> supportsRestartFrame;
  // The debug adapter supports the 'restart' request. In this case a client
  // should not implement 'restart' by terminating and relaunching the adapter
  // but by calling the RestartRequest.
  optional<boolean> supportsRestartRequest;
  // The debug adapter supports the 'setExpression' request.
  optional<boolean> supportsSetExpression;
  // The debug adapter supports setting a variable to a value.
  optional<boolean> supportsSetVariable;
  // The debug adapter supports stepping back via the 'stepBack' and
  // 'reverseContinue' requests.
  optional<boolean> supportsStepBack;
  // The debug adapter supports the 'stepInTargets' request.
  optional<boolean> supportsStepInTargetsRequest;
  // The debug adapter supports the 'terminate' request.
  optional<boolean> supportsTerminateRequest;
  // The debug adapter supports the 'terminateThreads' request.
  optional<boolean> supportsTerminateThreadsRequest;
  // The debug adapter supports a 'format' attribute on the stackTraceRequest,
  // variablesRequest, and evaluateRequest.
  optional<boolean> supportsValueFormattingOptions;
};

DAP_DECLARE_STRUCT_TYPEINFO(Capabilities);

// The event indicates that one or more capabilities have changed.
// Since the capabilities are dependent on the frontend and its UI, it might not
// be possible to change that at random times (or too late). Consequently this
// event has a hint characteristic: a frontend can only be expected to make a
// 'best effort' in honouring individual capabilities but there are no
// guarantees. Only changed capabilities need to be included, all other
// capabilities keep their values.
struct CapabilitiesEvent : public Event {
  CapabilitiesEvent();
  ~CapabilitiesEvent();

  // The set of updated capabilities.
  Capabilities capabilities;
};

DAP_DECLARE_STRUCT_TYPEINFO(CapabilitiesEvent);

// Some predefined types for the CompletionItem. Please note that not all
// clients have specific icons for all of them.
struct CompletionItemType {
  CompletionItemType();
  ~CompletionItemType();
};

DAP_DECLARE_STRUCT_TYPEINFO(CompletionItemType);

// CompletionItems are the suggestions returned from the CompletionsRequest.
struct CompletionItem {
  CompletionItem();
  ~CompletionItem();

  // The label of this completion item. By default this is also the text that is
  // inserted when selecting this completion.
  string label;
  // This value determines how many characters are overwritten by the completion
  // text. If missing the value 0 is assumed which results in the completion
  // text being inserted.
  optional<integer> length;
  // A string that should be used when comparing this item with other items.
  // When `falsy` the label is used.
  optional<string> sortText;
  // This value determines the location (in the CompletionsRequest's 'text'
  // attribute) where the completion text is added. If missing the text is added
  // at the location specified by the CompletionsRequest's 'column' attribute.
  optional<integer> start;
  // If text is not falsy then it is inserted instead of the label.
  optional<string> text;
  // The item's type. Typically the client uses this information to render the
  // item in the UI with an icon.
  optional<CompletionItemType> type;
};

DAP_DECLARE_STRUCT_TYPEINFO(CompletionItem);

// Response to 'completions' request.
struct CompletionsResponse : public Response {
  CompletionsResponse();
  ~CompletionsResponse();

  // The possible completions for .
  array<CompletionItem> targets;
};

DAP_DECLARE_STRUCT_TYPEINFO(CompletionsResponse);

// Returns a list of possible completions for a given caret position and text.
// The CompletionsRequest may only be called if the 'supportsCompletionsRequest'
// capability exists and is true.
struct CompletionsRequest : public Request {
  using Response = CompletionsResponse;

  CompletionsRequest();
  ~CompletionsRequest();

  // The character position for which to determine the completion proposals.
  integer column;
  // Returns completions in the scope of this stack frame. If not specified, the
  // completions are returned for the global scope.
  optional<integer> frameId;
  // An optional line for which to determine the completion proposals. If
  // missing the first line of the text is assumed.
  optional<integer> line;
  // One or more source lines. Typically this is the text a user has typed into
  // the debug console before he asked for completion.
  string text;
};

DAP_DECLARE_STRUCT_TYPEINFO(CompletionsRequest);

// Response to 'configurationDone' request. This is just an acknowledgement, so
// no body field is required.
struct ConfigurationDoneResponse : public Response {
  ConfigurationDoneResponse();
  ~ConfigurationDoneResponse();
};

DAP_DECLARE_STRUCT_TYPEINFO(ConfigurationDoneResponse);

// The client of the debug protocol must send this request at the end of the
// sequence of configuration requests (which was started by the 'initialized'
// event).
struct ConfigurationDoneRequest : public Request {
  using Response = ConfigurationDoneResponse;

  ConfigurationDoneRequest();
  ~ConfigurationDoneRequest();
};

DAP_DECLARE_STRUCT_TYPEINFO(ConfigurationDoneRequest);

// Response to 'continue' request.
struct ContinueResponse : public Response {
  ContinueResponse();
  ~ContinueResponse();

  // If true, the 'continue' request has ignored the specified thread and
  // continued all threads instead. If this attribute is missing a value of
  // 'true' is assumed for backward compatibility.
  optional<boolean> allThreadsContinued;
};

DAP_DECLARE_STRUCT_TYPEINFO(ContinueResponse);

// The request starts the debuggee to run again.
struct ContinueRequest : public Request {
  using Response = ContinueResponse;

  ContinueRequest();
  ~ContinueRequest();

  // Continue execution for the specified thread (if possible). If the backend
  // cannot continue on a single thread but will continue on all threads, it
  // should set the 'allThreadsContinued' attribute in the response to true.
  integer threadId;
};

DAP_DECLARE_STRUCT_TYPEINFO(ContinueRequest);

// The event indicates that the execution of the debuggee has continued.
// Please note: a debug adapter is not expected to send this event in response
// to a request that implies that execution continues, e.g. 'launch' or
// 'continue'. It is only necessary to send a 'continued' event if there was no
// previous request that implied this.
struct ContinuedEvent : public Event {
  ContinuedEvent();
  ~ContinuedEvent();

  // If 'allThreadsContinued' is true, a debug adapter can announce that all
  // threads have continued.
  optional<boolean> allThreadsContinued;
  // The thread which was continued.
  integer threadId;
};

DAP_DECLARE_STRUCT_TYPEINFO(ContinuedEvent);

// This enumeration defines all possible access types for data breakpoints.
struct DataBreakpointAccessType {
  DataBreakpointAccessType();
  ~DataBreakpointAccessType();
};

DAP_DECLARE_STRUCT_TYPEINFO(DataBreakpointAccessType);

// Response to 'dataBreakpointInfo' request.
struct DataBreakpointInfoResponse : public Response {
  DataBreakpointInfoResponse();
  ~DataBreakpointInfoResponse();

  // Optional attribute listing the available access types for a potential data
  // breakpoint. A UI frontend could surface this information.
  optional<array<DataBreakpointAccessType>> accessTypes;
  // Optional attribute indicating that a potential data breakpoint could be
  // persisted across sessions.
  optional<boolean> canPersist;
  // An identifier for the data on which a data breakpoint can be registered
  // with the setDataBreakpoints request or null if no data breakpoint is
  // available.
  variant<string, null> dataId;
  // UI string that describes on what data the breakpoint is set on or why a
  // data breakpoint is not available.
  string description;
};

DAP_DECLARE_STRUCT_TYPEINFO(DataBreakpointInfoResponse);

// Obtains information on a possible data breakpoint that could be set on an
// expression or variable.
struct DataBreakpointInfoRequest : public Request {
  using Response = DataBreakpointInfoResponse;

  DataBreakpointInfoRequest();
  ~DataBreakpointInfoRequest();

  // The name of the Variable's child to obtain data breakpoint information for.
  // If variableReference isnâ€™t provided, this can be an expression.
  string name;
  // Reference to the Variable container if the data breakpoint is requested for
  // a child of the container.
  optional<integer> variablesReference;
};

DAP_DECLARE_STRUCT_TYPEINFO(DataBreakpointInfoRequest);

// Represents a single disassembled instruction.
struct DisassembledInstruction {
  DisassembledInstruction();
  ~DisassembledInstruction();

  // The address of the instruction. Treated as a hex value if prefixed with
  // '0x', or as a decimal value otherwise.
  string address;
  // The column within the line that corresponds to this instruction, if any.
  optional<integer> column;
  // The end column of the range that corresponds to this instruction, if any.
  optional<integer> endColumn;
  // The end line of the range that corresponds to this instruction, if any.
  optional<integer> endLine;
  // Text representing the instruction and its operands, in an
  // implementation-defined format.
  string instruction;
  // Optional raw bytes representing the instruction and its operands, in an
  // implementation-defined format.
  optional<string> instructionBytes;
  // The line within the source location that corresponds to this instruction,
  // if any.
  optional<integer> line;
  // Source location that corresponds to this instruction, if any. Should always
  // be set (if available) on the first instruction returned, but can be omitted
  // afterwards if this instruction maps to the same source file as the previous
  // instruction.
  optional<Source> location;
  // Name of the symbol that corresponds with the location of this instruction,
  // if any.
  optional<string> symbol;
};

DAP_DECLARE_STRUCT_TYPEINFO(DisassembledInstruction);

// Response to 'disassemble' request.
struct DisassembleResponse : public Response {
  DisassembleResponse();
  ~DisassembleResponse();

  // The list of disassembled instructions.
  array<DisassembledInstruction> instructions;
};

DAP_DECLARE_STRUCT_TYPEINFO(DisassembleResponse);

// Disassembles code stored at the provided location.
struct DisassembleRequest : public Request {
  using Response = DisassembleResponse;

  DisassembleRequest();
  ~DisassembleRequest();

  // Number of instructions to disassemble starting at the specified location
  // and offset. An adapter must return exactly this number of instructions -
  // any unavailable instructions should be replaced with an
  // implementation-defined 'invalid instruction' value.
  integer instructionCount;
  // Optional offset (in instructions) to be applied after the byte offset (if
  // any) before disassembling. Can be negative.
  optional<integer> instructionOffset;
  // Memory reference to the base location containing the instructions to
  // disassemble.
  string memoryReference;
  // Optional offset (in bytes) to be applied to the reference location before
  // disassembling. Can be negative.
  optional<integer> offset;
  // If true, the adapter should attempt to resolve memory addresses and other
  // values to symbolic names.
  optional<boolean> resolveSymbols;
};

DAP_DECLARE_STRUCT_TYPEINFO(DisassembleRequest);

// Response to 'disconnect' request. This is just an acknowledgement, so no body
// field is required.
struct DisconnectResponse : public Response {
  DisconnectResponse();
  ~DisconnectResponse();
};

DAP_DECLARE_STRUCT_TYPEINFO(DisconnectResponse);

// The 'disconnect' request is sent from the client to the debug adapter in
// order to stop debugging. It asks the debug adapter to disconnect from the
// debuggee and to terminate the debug adapter. If the debuggee has been started
// with the 'launch' request, the 'disconnect' request terminates the debuggee.
// If the 'attach' request was used to connect to the debuggee, 'disconnect'
// does not terminate the debuggee. This behavior can be controlled with the
// 'terminateDebuggee' argument (if supported by the debug adapter).
struct DisconnectRequest : public Request {
  using Response = DisconnectResponse;

  DisconnectRequest();
  ~DisconnectRequest();

  // A value of true indicates that this 'disconnect' request is part of a
  // restart sequence.
  optional<boolean> restart;
  // Indicates whether the debuggee should be terminated when the debugger is
  // disconnected. If unspecified, the debug adapter is free to do whatever it
  // thinks is best. A client can only rely on this attribute being properly
  // honored if a debug adapter returns true for the 'supportTerminateDebuggee'
  // capability.
  optional<boolean> terminateDebuggee;
};

DAP_DECLARE_STRUCT_TYPEINFO(DisconnectRequest);

// A structured message object. Used to return errors from requests.
struct Message {
  Message();
  ~Message();

  // A format string for the message. Embedded variables have the form '{name}'.
  // If variable name starts with an underscore character, the variable does not
  // contain user data (PII) and can be safely used for telemetry purposes.
  string format;
  // Unique identifier for the message.
  integer id;
  // If true send to telemetry.
  optional<boolean> sendTelemetry;
  // If true show user.
  optional<boolean> showUser;
  // An optional url where additional information about this message can be
  // found.
  optional<string> url;
  // An optional label that is presented to the user as the UI for opening the
  // url.
  optional<string> urlLabel;
  // An object used as a dictionary for looking up the variables in the format
  // string.
  optional<object> variables;
};

DAP_DECLARE_STRUCT_TYPEINFO(Message);

// On error (whenever 'success' is false), the body can provide more details.
struct ErrorResponse : public Response {
  ErrorResponse();
  ~ErrorResponse();

  // An optional, structured error message.
  optional<Message> error;
};

DAP_DECLARE_STRUCT_TYPEINFO(ErrorResponse);

// Optional properties of a variable that can be used to determine how to render
// the variable in the UI.
struct VariablePresentationHint {
  VariablePresentationHint();
  ~VariablePresentationHint();

  // Set of attributes represented as an array of strings. Before introducing
  // additional values, try to use the listed values.
  optional<array<string>> attributes;
  // The kind of variable. Before introducing additional values, try to use the
  // listed values.
  //
  // May be one of the following enumeration values:
  // 'property', 'method', 'class', 'data', 'event', 'baseClass', 'innerClass',
  // 'interface', 'mostDerivedClass', 'virtual', 'dataBreakpoint'
  optional<string> kind;
  // Visibility of variable. Before introducing additional values, try to use
  // the listed values.
  //
  // May be one of the following enumeration values:
  // 'public', 'private', 'protected', 'internal', 'final'
  optional<string> visibility;
};

DAP_DECLARE_STRUCT_TYPEINFO(VariablePresentationHint);

// Response to 'evaluate' request.
struct EvaluateResponse : public Response {
  EvaluateResponse();
  ~EvaluateResponse();

  // The number of indexed child variables.
  // The client can use this optional information to present the variables in a
  // paged UI and fetch them in chunks. The value should be less than or equal
  // to 2147483647 (2^31 - 1).
  optional<integer> indexedVariables;
  // Memory reference to a location appropriate for this result. For pointer
  // type eval results, this is generally a reference to the memory address
  // contained in the pointer.
  optional<string> memoryReference;
  // The number of named child variables.
  // The client can use this optional information to present the variables in a
  // paged UI and fetch them in chunks. The value should be less than or equal
  // to 2147483647 (2^31 - 1).
  optional<integer> namedVariables;
  // Properties of a evaluate result that can be used to determine how to render
  // the result in the UI.
  optional<VariablePresentationHint> presentationHint;
  // The result of the evaluate request.
  string result;
  // The optional type of the evaluate result.
  optional<string> type;
  // If variablesReference is > 0, the evaluate result is structured and its
  // children can be retrieved by passing variablesReference to the
  // VariablesRequest. The value should be less than or equal to 2147483647
  // (2^31 - 1).
  integer variablesReference;
};

DAP_DECLARE_STRUCT_TYPEINFO(EvaluateResponse);

// Provides formatting information for a value.
struct ValueFormat {
  ValueFormat();
  ~ValueFormat();

  // Display the value in hex.
  optional<boolean> hex;
};

DAP_DECLARE_STRUCT_TYPEINFO(ValueFormat);

// Evaluates the given expression in the context of the top most stack frame.
// The expression has access to any variables and arguments that are in scope.
struct EvaluateRequest : public Request {
  using Response = EvaluateResponse;

  EvaluateRequest();
  ~EvaluateRequest();

  // The context in which the evaluate request is run.
  //
  // May be one of the following enumeration values:
  // 'watch', 'repl', 'hover'
  optional<string> context;
  // The expression to evaluate.
  string expression;
  // Specifies details on how to format the Evaluate result.
  optional<ValueFormat> format;
  // Evaluate the expression in the scope of this stack frame. If not specified,
  // the expression is evaluated in the global scope.
  optional<integer> frameId;
};

DAP_DECLARE_STRUCT_TYPEINFO(EvaluateRequest);

// This enumeration defines all possible conditions when a thrown exception
// should result in a break. never: never breaks, always: always breaks,
// unhandled: breaks when exception unhandled,
// userUnhandled: breaks if the exception is not handled by user code.
struct ExceptionBreakMode {
  ExceptionBreakMode();
  ~ExceptionBreakMode();
};

DAP_DECLARE_STRUCT_TYPEINFO(ExceptionBreakMode);

// Detailed information about an exception that has occurred.
struct ExceptionDetails {
  ExceptionDetails();
  ~ExceptionDetails();

  // Optional expression that can be evaluated in the current scope to obtain
  // the exception object.
  optional<string> evaluateName;
  // Fully-qualified type name of the exception object.
  optional<string> fullTypeName;
  // Details of the exception contained by this exception, if any.
  optional<array<ExceptionDetails>> innerException;
  // Message contained in the exception.
  optional<string> message;
  // Stack trace at the time the exception was thrown.
  optional<string> stackTrace;
  // Short type name of the exception object.
  optional<string> typeName;
};

DAP_DECLARE_STRUCT_TYPEINFO(ExceptionDetails);

// Response to 'exceptionInfo' request.
struct ExceptionInfoResponse : public Response {
  ExceptionInfoResponse();
  ~ExceptionInfoResponse();

  // Mode that caused the exception notification to be raised.
  ExceptionBreakMode breakMode;
  // Descriptive text for the exception provided by the debug adapter.
  optional<string> description;
  // Detailed information about the exception.
  optional<ExceptionDetails> details;
  // ID of the exception that was thrown.
  string exceptionId;
};

DAP_DECLARE_STRUCT_TYPEINFO(ExceptionInfoResponse);

// Retrieves the details of the exception that caused this event to be raised.
struct ExceptionInfoRequest : public Request {
  using Response = ExceptionInfoResponse;

  ExceptionInfoRequest();
  ~ExceptionInfoRequest();

  // Thread for which exception information should be retrieved.
  integer threadId;
};

DAP_DECLARE_STRUCT_TYPEINFO(ExceptionInfoRequest);

// The event indicates that the debuggee has exited and returns its exit code.
struct ExitedEvent : public Event {
  ExitedEvent();
  ~ExitedEvent();

  // The exit code returned from the debuggee.
  integer exitCode;
};

DAP_DECLARE_STRUCT_TYPEINFO(ExitedEvent);

// Response to 'goto' request. This is just an acknowledgement, so no body field
// is required.
struct GotoResponse : public Response {
  GotoResponse();
  ~GotoResponse();
};

DAP_DECLARE_STRUCT_TYPEINFO(GotoResponse);

// The request sets the location where the debuggee will continue to run.
// This makes it possible to skip the execution of code or to executed code
// again. The code between the current location and the goto target is not
// executed but skipped. The debug adapter first sends the response and then a
// 'stopped' event with reason 'goto'.
struct GotoRequest : public Request {
  using Response = GotoResponse;

  GotoRequest();
  ~GotoRequest();

  // The location where the debuggee will continue to run.
  integer targetId;
  // Set the goto target for this thread.
  integer threadId;
};

DAP_DECLARE_STRUCT_TYPEINFO(GotoRequest);

// A GotoTarget describes a code location that can be used as a target in the
// 'goto' request. The possible goto targets can be determined via the
// 'gotoTargets' request.
struct GotoTarget {
  GotoTarget();
  ~GotoTarget();

  // An optional column of the goto target.
  optional<integer> column;
  // An optional end column of the range covered by the goto target.
  optional<integer> endColumn;
  // An optional end line of the range covered by the goto target.
  optional<integer> endLine;
  // Unique identifier for a goto target. This is used in the goto request.
  integer id;
  // Optional memory reference for the instruction pointer value represented by
  // this target.
  optional<string> instructionPointerReference;
  // The name of the goto target (shown in the UI).
  string label;
  // The line of the goto target.
  integer line;
};

DAP_DECLARE_STRUCT_TYPEINFO(GotoTarget);

// Response to 'gotoTargets' request.
struct GotoTargetsResponse : public Response {
  GotoTargetsResponse();
  ~GotoTargetsResponse();

  // The possible goto targets of the specified location.
  array<GotoTarget> targets;
};

DAP_DECLARE_STRUCT_TYPEINFO(GotoTargetsResponse);

// This request retrieves the possible goto targets for the specified source
// location. These targets can be used in the 'goto' request. The GotoTargets
// request may only be called if the 'supportsGotoTargetsRequest' capability
// exists and is true.
struct GotoTargetsRequest : public Request {
  using Response = GotoTargetsResponse;

  GotoTargetsRequest();
  ~GotoTargetsRequest();

  // An optional column location for which the goto targets are determined.
  optional<integer> column;
  // The line location for which the goto targets are determined.
  integer line;
  // The source location for which the goto targets are determined.
  Source source;
};

DAP_DECLARE_STRUCT_TYPEINFO(GotoTargetsRequest);

// Response to 'initialize' request.
struct InitializeResponse : public Response {
  InitializeResponse();
  ~InitializeResponse();

  // The set of additional module information exposed by the debug adapter.
  optional<array<ColumnDescriptor>> additionalModuleColumns;
  // The set of characters that should trigger completion in a REPL. If not
  // specified, the UI should assume the '.' character.
  optional<array<string>> completionTriggerCharacters;
  // Available filters or options for the setExceptionBreakpoints request.
  optional<array<ExceptionBreakpointsFilter>> exceptionBreakpointFilters;
  // The debug adapter supports the 'terminateDebuggee' attribute on the
  // 'disconnect' request.
  optional<boolean> supportTerminateDebuggee;
  // Checksum algorithms supported by the debug adapter.
  optional<array<ChecksumAlgorithm>> supportedChecksumAlgorithms;
  // The debug adapter supports the 'breakpointLocations' request.
  optional<boolean> supportsBreakpointLocationsRequest;
  // The debug adapter supports the 'cancel' request.
  optional<boolean> supportsCancelRequest;
  // The debug adapter supports the 'completions' request.
  optional<boolean> supportsCompletionsRequest;
  // The debug adapter supports conditional breakpoints.
  optional<boolean> supportsConditionalBreakpoints;
  // The debug adapter supports the 'configurationDone' request.
  optional<boolean> supportsConfigurationDoneRequest;
  // The debug adapter supports data breakpoints.
  optional<boolean> supportsDataBreakpoints;
  // The debug adapter supports the delayed loading of parts of the stack, which
  // requires that both the 'startFrame' and 'levels' arguments and the
  // 'totalFrames' result of the 'StackTrace' request are supported.
  optional<boolean> supportsDelayedStackTraceLoading;
  // The debug adapter supports the 'disassemble' request.
  optional<boolean> supportsDisassembleRequest;
  // The debug adapter supports a (side effect free) evaluate request for data
  // hovers.
  optional<boolean> supportsEvaluateForHovers;
  // The debug adapter supports the 'exceptionInfo' request.
  optional<boolean> supportsExceptionInfoRequest;
  // The debug adapter supports 'exceptionOptions' on the
  // setExceptionBreakpoints request.
  optional<boolean> supportsExceptionOptions;
  // The debug adapter supports function breakpoints.
  optional<boolean> supportsFunctionBreakpoints;
  // The debug adapter supports the 'gotoTargets' request.
  optional<boolean> supportsGotoTargetsRequest;
  // The debug adapter supports breakpoints that break execution after a
  // specified number of hits.
  optional<boolean> supportsHitConditionalBreakpoints;
  // The debug adapter supports the 'loadedSources' request.
  optional<boolean> supportsLoadedSourcesRequest;
  // The debug adapter supports logpoints by interpreting the 'logMessage'
  // attribute of the SourceBreakpoint.
  optional<boolean> supportsLogPoints;
  // The debug adapter supports the 'modules' request.
  optional<boolean> supportsModulesRequest;
  // The debug adapter supports the 'readMemory' request.
  optional<boolean> supportsReadMemoryRequest;
  // The debug adapter supports restarting a frame.
  optional<boolean> supportsRestartFrame;
  // The debug adapter supports the 'restart' request. In this case a client
  // should not implement 'restart' by terminating and relaunching the adapter
  // but by calling the RestartRequest.
  optional<boolean> supportsRestartRequest;
  // The debug adapter supports the 'setExpression' request.
  optional<boolean> supportsSetExpression;
  // The debug adapter supports setting a variable to a value.
  optional<boolean> supportsSetVariable;
  // The debug adapter supports stepping back via the 'stepBack' and
  // 'reverseContinue' requests.
  optional<boolean> supportsStepBack;
  // The debug adapter supports the 'stepInTargets' request.
  optional<boolean> supportsStepInTargetsRequest;
  // The debug adapter supports the 'terminate' request.
  optional<boolean> supportsTerminateRequest;
  // The debug adapter supports the 'terminateThreads' request.
  optional<boolean> supportsTerminateThreadsRequest;
  // The debug adapter supports a 'format' attribute on the stackTraceRequest,
  // variablesRequest, and evaluateRequest.
  optional<boolean> supportsValueFormattingOptions;
};

DAP_DECLARE_STRUCT_TYPEINFO(InitializeResponse);

// The 'initialize' request is sent as the first request from the client to the
// debug adapter in order to configure it with client capabilities and to
// retrieve capabilities from the debug adapter. Until the debug adapter has
// responded to with an 'initialize' response, the client must not send any
// additional requests or events to the debug adapter. In addition the debug
// adapter is not allowed to send any requests or events to the client until it
// has responded with an 'initialize' response. The 'initialize' request may
// only be sent once.
struct InitializeRequest : public Request {
  using Response = InitializeResponse;

  InitializeRequest();
  ~InitializeRequest();

  // The ID of the debug adapter.
  string adapterID;
  // The ID of the (frontend) client using this adapter.
  optional<string> clientID;
  // The human readable name of the (frontend) client using this adapter.
  optional<string> clientName;
  // If true all column numbers are 1-based (default).
  optional<boolean> columnsStartAt1;
  // If true all line numbers are 1-based (default).
  optional<boolean> linesStartAt1;
  // The ISO-639 locale of the (frontend) client using this adapter, e.g. en-US
  // or de-CH.
  optional<string> locale;
  // Determines in what format paths are specified. The default is 'path', which
  // is the native format.
  //
  // May be one of the following enumeration values:
  // 'path', 'uri'
  optional<string> pathFormat;
  // Client supports memory references.
  optional<boolean> supportsMemoryReferences;
  // Client supports the runInTerminal request.
  optional<boolean> supportsRunInTerminalRequest;
  // Client supports the paging of variables.
  optional<boolean> supportsVariablePaging;
  // Client supports the optional type attribute for variables.
  optional<boolean> supportsVariableType;
};

DAP_DECLARE_STRUCT_TYPEINFO(InitializeRequest);

// This event indicates that the debug adapter is ready to accept configuration
// requests (e.g. SetBreakpointsRequest, SetExceptionBreakpointsRequest). A
// debug adapter is expected to send this event when it is ready to accept
// configuration requests (but not before the 'initialize' request has
// finished). The sequence of events/requests is as follows:
// - adapters sends 'initialized' event (after the 'initialize' request has
// returned)
// - frontend sends zero or more 'setBreakpoints' requests
// - frontend sends one 'setFunctionBreakpoints' request
// - frontend sends a 'setExceptionBreakpoints' request if one or more
// 'exceptionBreakpointFilters' have been defined (or if
// 'supportsConfigurationDoneRequest' is not defined or false)
// - frontend sends other future configuration requests
// - frontend sends one 'configurationDone' request to indicate the end of the
// configuration.
struct InitializedEvent : public Event {
  InitializedEvent();
  ~InitializedEvent();
};

DAP_DECLARE_STRUCT_TYPEINFO(InitializedEvent);

// Response to 'launch' request. This is just an acknowledgement, so no body
// field is required.
struct LaunchResponse : public Response {
  LaunchResponse();
  ~LaunchResponse();
};

DAP_DECLARE_STRUCT_TYPEINFO(LaunchResponse);

// The launch request is sent from the client to the debug adapter to start the
// debuggee with or without debugging (if 'noDebug' is true). Since launching is
// debugger/runtime specific, the arguments for this request are not part of
// this specification.
struct LaunchRequest : public Request {
  using Response = LaunchResponse;

  LaunchRequest();
  ~LaunchRequest();

  // Optional data from the previous, restarted session.
  // The data is sent as the 'restart' attribute of the 'terminated' event.
  // The client should leave the data intact.
  optional<variant<array<any>, boolean, integer, null, number, object, string>>
      restart;
  // If noDebug is true the launch request should launch the program without
  // enabling debugging.
  optional<boolean> noDebug;
};

DAP_DECLARE_STRUCT_TYPEINFO(LaunchRequest);

// The event indicates that some source has been added, changed, or removed from
// the set of all loaded sources.
struct LoadedSourceEvent : public Event {
  LoadedSourceEvent();
  ~LoadedSourceEvent();

  // The reason for the event.
  //
  // Must be one of the following enumeration values:
  // 'new', 'changed', 'removed'
  string reason = "new";
  // The new, changed, or removed source.
  Source source;
};

DAP_DECLARE_STRUCT_TYPEINFO(LoadedSourceEvent);

// Response to 'loadedSources' request.
struct LoadedSourcesResponse : public Response {
  LoadedSourcesResponse();
  ~LoadedSourcesResponse();

  // Set of loaded sources.
  array<Source> sources;
};

DAP_DECLARE_STRUCT_TYPEINFO(LoadedSourcesResponse);

// Retrieves the set of all sources currently loaded by the debugged process.
struct LoadedSourcesRequest : public Request {
  using Response = LoadedSourcesResponse;

  LoadedSourcesRequest();
  ~LoadedSourcesRequest();
};

DAP_DECLARE_STRUCT_TYPEINFO(LoadedSourcesRequest);

// A Module object represents a row in the modules view.
// Two attributes are mandatory: an id identifies a module in the modules view
// and is used in a ModuleEvent for identifying a module for adding, updating or
// deleting. The name is used to minimally render the module in the UI.
//
// Additional attributes can be added to the module. They will show up in the
// module View if they have a corresponding ColumnDescriptor.
//
// To avoid an unnecessary proliferation of additional attributes with similar
// semantics but different names we recommend to re-use attributes from the
// 'recommended' list below first, and only introduce new attributes if nothing
// appropriate could be found.
struct Module {
  Module();
  ~Module();

  // Address range covered by this module.
  optional<string> addressRange;
  // Module created or modified.
  optional<string> dateTimeStamp;
  // Unique identifier for the module.
  variant<integer, string> id;
  // True if the module is optimized.
  optional<boolean> isOptimized;
  // True if the module is considered 'user code' by a debugger that supports
  // 'Just My Code'.
  optional<boolean> isUserCode;
  // A name of the module.
  string name;
  // optional but recommended attributes.
  // always try to use these first before introducing additional attributes.
  //
  // Logical full path to the module. The exact definition is implementation
  // defined, but usually this would be a full path to the on-disk file for the
  // module.
  optional<string> path;
  // Logical full path to the symbol file. The exact definition is
  // implementation defined.
  optional<string> symbolFilePath;
  // User understandable description of if symbols were found for the module
  // (ex: 'Symbols Loaded', 'Symbols not found', etc.
  optional<string> symbolStatus;
  // Version of Module.
  optional<string> version;
};

DAP_DECLARE_STRUCT_TYPEINFO(Module);

// The event indicates that some information about a module has changed.
struct ModuleEvent : public Event {
  ModuleEvent();
  ~ModuleEvent();

  // The new, changed, or removed module. In case of 'removed' only the module
  // id is used.
  Module module;
  // The reason for the event.
  //
  // Must be one of the following enumeration values:
  // 'new', 'changed', 'removed'
  string reason = "new";
};

DAP_DECLARE_STRUCT_TYPEINFO(ModuleEvent);

// Response to 'modules' request.
struct ModulesResponse : public Response {
  ModulesResponse();
  ~ModulesResponse();

  // All modules or range of modules.
  array<Module> modules;
  // The total number of modules available.
  optional<integer> totalModules;
};

DAP_DECLARE_STRUCT_TYPEINFO(ModulesResponse);

// Modules can be retrieved from the debug adapter with the ModulesRequest which
// can either return all modules or a range of modules to support paging.
struct ModulesRequest : public Request {
  using Response = ModulesResponse;

  ModulesRequest();
  ~ModulesRequest();

  // The number of modules to return. If moduleCount is not specified or 0, all
  // modules are returned.
  optional<integer> moduleCount;
  // The index of the first module to return; if omitted modules start at 0.
  optional<integer> startModule;
};

DAP_DECLARE_STRUCT_TYPEINFO(ModulesRequest);

// Response to 'next' request. This is just an acknowledgement, so no body field
// is required.
struct NextResponse : public Response {
  NextResponse();
  ~NextResponse();
};

DAP_DECLARE_STRUCT_TYPEINFO(NextResponse);

// The request starts the debuggee to run again for one step.
// The debug adapter first sends the response and then a 'stopped' event (with
// reason 'step') after the step has completed.
struct NextRequest : public Request {
  using Response = NextResponse;

  NextRequest();
  ~NextRequest();

  // Execute 'next' for this thread.
  integer threadId;
};

DAP_DECLARE_STRUCT_TYPEINFO(NextRequest);

// The event indicates that the target has produced some output.
struct OutputEvent : public Event {
  OutputEvent();
  ~OutputEvent();

  // The output category. If not specified, 'console' is assumed.
  //
  // May be one of the following enumeration values:
  // 'console', 'stdout', 'stderr', 'telemetry'
  optional<string> category;
  // An optional source location column where the output was produced.
  optional<integer> column;
  // Optional data to report. For the 'telemetry' category the data will be sent
  // to telemetry, for the other categories the data is shown in JSON format.
  optional<variant<array<any>, boolean, integer, null, number, object, string>>
      data;
  // An optional source location line where the output was produced.
  optional<integer> line;
  // The output to report.
  string output;
  // An optional source location where the output was produced.
  optional<Source> source;
  // If an attribute 'variablesReference' exists and its value is > 0, the
  // output contains objects which can be retrieved by passing
  // 'variablesReference' to the 'variables' request. The value should be less
  // than or equal to 2147483647 (2^31 - 1).
  optional<integer> variablesReference;
};

DAP_DECLARE_STRUCT_TYPEINFO(OutputEvent);

// Response to 'pause' request. This is just an acknowledgement, so no body
// field is required.
struct PauseResponse : public Response {
  PauseResponse();
  ~PauseResponse();
};

DAP_DECLARE_STRUCT_TYPEINFO(PauseResponse);

// The request suspends the debuggee.
// The debug adapter first sends the response and then a 'stopped' event (with
// reason 'pause') after the thread has been paused successfully.
struct PauseRequest : public Request {
  using Response = PauseResponse;

  PauseRequest();
  ~PauseRequest();

  // Pause execution for this thread.
  integer threadId;
};

DAP_DECLARE_STRUCT_TYPEINFO(PauseRequest);

// The event indicates that the debugger has begun debugging a new process.
// Either one that it has launched, or one that it has attached to.
struct ProcessEvent : public Event {
  ProcessEvent();
  ~ProcessEvent();

  // If true, the process is running on the same computer as the debug adapter.
  optional<boolean> isLocalProcess;
  // The logical name of the process. This is usually the full path to process's
  // executable file. Example: /home/example/myproj/program.js.
  string name;
  // The size of a pointer or address for this process, in bits. This value may
  // be used by clients when formatting addresses for display.
  optional<integer> pointerSize;
  // Describes how the debug engine started debugging this process.
  //
  // Must be one of the following enumeration values:
  // 'launch', 'attach', 'attachForSuspendedLaunch'
  optional<string> startMethod;
  // The system process id of the debugged process. This property will be
  // missing for non-system processes.
  optional<integer> systemProcessId;
};

DAP_DECLARE_STRUCT_TYPEINFO(ProcessEvent);

// Response to 'readMemory' request.
struct ReadMemoryResponse : public Response {
  ReadMemoryResponse();
  ~ReadMemoryResponse();

  // The address of the first byte of data returned. Treated as a hex value if
  // prefixed with '0x', or as a decimal value otherwise.
  string address;
  // The bytes read from memory, encoded using base64.
  optional<string> data;
  // The number of unreadable bytes encountered after the last successfully read
  // byte. This can be used to determine the number of bytes that must be
  // skipped before a subsequent 'readMemory' request will succeed.
  optional<integer> unreadableBytes;
};

DAP_DECLARE_STRUCT_TYPEINFO(ReadMemoryResponse);

// Reads bytes from memory at the provided location.
struct ReadMemoryRequest : public Request {
  using Response = ReadMemoryResponse;

  ReadMemoryRequest();
  ~ReadMemoryRequest();

  // Number of bytes to read at the specified location and offset.
  integer count;
  // Memory reference to the base location from which data should be read.
  string memoryReference;
  // Optional offset (in bytes) to be applied to the reference location before
  // reading data. Can be negative.
  optional<integer> offset;
};

DAP_DECLARE_STRUCT_TYPEINFO(ReadMemoryRequest);

// Response to 'restartFrame' request. This is just an acknowledgement, so no
// body field is required.
struct RestartFrameResponse : public Response {
  RestartFrameResponse();
  ~RestartFrameResponse();
};

DAP_DECLARE_STRUCT_TYPEINFO(RestartFrameResponse);

// The request restarts execution of the specified stackframe.
// The debug adapter first sends the response and then a 'stopped' event (with
// reason 'restart') after the restart has completed.
struct RestartFrameRequest : public Request {
  using Response = RestartFrameResponse;

  RestartFrameRequest();
  ~RestartFrameRequest();

  // Restart this stackframe.
  integer frameId;
};

DAP_DECLARE_STRUCT_TYPEINFO(RestartFrameRequest);

// Response to 'restart' request. This is just an acknowledgement, so no body
// field is required.
struct RestartResponse : public Response {
  RestartResponse();
  ~RestartResponse();
};

DAP_DECLARE_STRUCT_TYPEINFO(RestartResponse);

// Restarts a debug session. If the capability 'supportsRestartRequest' is
// missing or has the value false, the client will implement 'restart' by
// terminating the debug adapter first and then launching it anew. A debug
// adapter can override this default behaviour by implementing a restart request
// and setting the capability 'supportsRestartRequest' to true.
struct RestartRequest : public Request {
  using Response = RestartResponse;

  RestartRequest();
  ~RestartRequest();
};

DAP_DECLARE_STRUCT_TYPEINFO(RestartRequest);

// Response to 'reverseContinue' request. This is just an acknowledgement, so no
// body field is required.
struct ReverseContinueResponse : public Response {
  ReverseContinueResponse();
  ~ReverseContinueResponse();
};

DAP_DECLARE_STRUCT_TYPEINFO(ReverseContinueResponse);

// The request starts the debuggee to run backward. Clients should only call
// this request if the capability 'supportsStepBack' is true.
struct ReverseContinueRequest : public Request {
  using Response = ReverseContinueResponse;

  ReverseContinueRequest();
  ~ReverseContinueRequest();

  // Execute 'reverseContinue' for this thread.
  integer threadId;
};

DAP_DECLARE_STRUCT_TYPEINFO(ReverseContinueRequest);

// Response to 'runInTerminal' request.
struct RunInTerminalResponse : public Response {
  RunInTerminalResponse();
  ~RunInTerminalResponse();

  // The process ID. The value should be less than or equal to 2147483647 (2^31
  // - 1).
  optional<integer> processId;
  // The process ID of the terminal shell. The value should be less than or
  // equal to 2147483647 (2^31 - 1).
  optional<integer> shellProcessId;
};

DAP_DECLARE_STRUCT_TYPEINFO(RunInTerminalResponse);

// This request is sent from the debug adapter to the client to run a command in
// a terminal. This is typically used to launch the debuggee in a terminal
// provided by the client.
struct RunInTerminalRequest : public Request {
  using Response = RunInTerminalResponse;

  RunInTerminalRequest();
  ~RunInTerminalRequest();

  // List of arguments. The first argument is the command to run.
  array<string> args;
  // Working directory of the command.
  string cwd;
  // Environment key-value pairs that are added to or removed from the default
  // environment.
  optional<object> env;
  // What kind of terminal to launch.
  //
  // Must be one of the following enumeration values:
  // 'integrated', 'external'
  optional<string> kind;
  // Optional title of the terminal.
  optional<string> title;
};

DAP_DECLARE_STRUCT_TYPEINFO(RunInTerminalRequest);

// A Scope is a named container for variables. Optionally a scope can map to a
// source or a range within a source.
struct Scope {
  Scope();
  ~Scope();

  // Optional start column of the range covered by this scope.
  optional<integer> column;
  // Optional end column of the range covered by this scope.
  optional<integer> endColumn;
  // Optional end line of the range covered by this scope.
  optional<integer> endLine;
  // If true, the number of variables in this scope is large or expensive to
  // retrieve.
  boolean expensive;
  // The number of indexed variables in this scope.
  // The client can use this optional information to present the variables in a
  // paged UI and fetch them in chunks.
  optional<integer> indexedVariables;
  // Optional start line of the range covered by this scope.
  optional<integer> line;
  // Name of the scope such as 'Arguments', 'Locals', or 'Registers'. This
  // string is shown in the UI as is and can be translated.
  string name;
  // The number of named variables in this scope.
  // The client can use this optional information to present the variables in a
  // paged UI and fetch them in chunks.
  optional<integer> namedVariables;
  // An optional hint for how to present this scope in the UI. If this attribute
  // is missing, the scope is shown with a generic UI.
  //
  // May be one of the following enumeration values:
  // 'arguments', 'locals', 'registers'
  optional<string> presentationHint;
  // Optional source for this scope.
  optional<Source> source;
  // The variables of this scope can be retrieved by passing the value of
  // variablesReference to the VariablesRequest.
  integer variablesReference;
};

DAP_DECLARE_STRUCT_TYPEINFO(Scope);

// Response to 'scopes' request.
struct ScopesResponse : public Response {
  ScopesResponse();
  ~ScopesResponse();

  // The scopes of the stackframe. If the array has length zero, there are no
  // scopes available.
  array<Scope> scopes;
};

DAP_DECLARE_STRUCT_TYPEINFO(ScopesResponse);

// The request returns the variable scopes for a given stackframe ID.
struct ScopesRequest : public Request {
  using Response = ScopesResponse;

  ScopesRequest();
  ~ScopesRequest();

  // Retrieve the scopes for this stackframe.
  integer frameId;
};

DAP_DECLARE_STRUCT_TYPEINFO(ScopesRequest);

// Response to 'setBreakpoints' request.
// Returned is information about each breakpoint created by this request.
// This includes the actual code location and whether the breakpoint could be
// verified. The breakpoints returned are in the same order as the elements of
// the 'breakpoints' (or the deprecated 'lines') array in the arguments.
struct SetBreakpointsResponse : public Response {
  SetBreakpointsResponse();
  ~SetBreakpointsResponse();

  // Information about the breakpoints. The array elements are in the same order
  // as the elements of the 'breakpoints' (or the deprecated 'lines') array in
  // the arguments.
  array<Breakpoint> breakpoints;
};

DAP_DECLARE_STRUCT_TYPEINFO(SetBreakpointsResponse);

// Properties of a breakpoint or logpoint passed to the setBreakpoints request.
struct SourceBreakpoint {
  SourceBreakpoint();
  ~SourceBreakpoint();

  // An optional source column of the breakpoint.
  optional<integer> column;
  // An optional expression for conditional breakpoints.
  optional<string> condition;
  // An optional expression that controls how many hits of the breakpoint are
  // ignored. The backend is expected to interpret the expression as needed.
  optional<string> hitCondition;
  // The source line of the breakpoint or logpoint.
  integer line;
  // If this attribute exists and is non-empty, the backend must not 'break'
  // (stop) but log the message instead. Expressions within {} are interpolated.
  optional<string> logMessage;
};

DAP_DECLARE_STRUCT_TYPEINFO(SourceBreakpoint);

// Sets multiple breakpoints for a single source and clears all previous
// breakpoints in that source. To clear all breakpoint for a source, specify an
// empty array. When a breakpoint is hit, a 'stopped' event (with reason
// 'breakpoint') is generated.
struct SetBreakpointsRequest : public Request {
  using Response = SetBreakpointsResponse;

  SetBreakpointsRequest();
  ~SetBreakpointsRequest();

  // The code locations of the breakpoints.
  optional<array<SourceBreakpoint>> breakpoints;
  // Deprecated: The code locations of the breakpoints.
  optional<array<integer>> lines;
  // The source location of the breakpoints; either 'source.path' or
  // 'source.reference' must be specified.
  Source source;
  // A value of true indicates that the underlying source has been modified
  // which results in new breakpoint locations.
  optional<boolean> sourceModified;
};

DAP_DECLARE_STRUCT_TYPEINFO(SetBreakpointsRequest);

// Response to 'setDataBreakpoints' request.
// Returned is information about each breakpoint created by this request.
struct SetDataBreakpointsResponse : public Response {
  SetDataBreakpointsResponse();
  ~SetDataBreakpointsResponse();

  // Information about the data breakpoints. The array elements correspond to
  // the elements of the input argument 'breakpoints' array.
  array<Breakpoint> breakpoints;
};

DAP_DECLARE_STRUCT_TYPEINFO(SetDataBreakpointsResponse);

// Properties of a data breakpoint passed to the setDataBreakpoints request.
struct DataBreakpoint {
  DataBreakpoint();
  ~DataBreakpoint();

  // The access type of the data.
  optional<DataBreakpointAccessType> accessType;
  // An optional expression for conditional breakpoints.
  optional<string> condition;
  // An id representing the data. This id is returned from the
  // dataBreakpointInfo request.
  string dataId;
  // An optional expression that controls how many hits of the breakpoint are
  // ignored. The backend is expected to interpret the expression as needed.
  optional<string> hitCondition;
};

DAP_DECLARE_STRUCT_TYPEINFO(DataBreakpoint);

// Replaces all existing data breakpoints with new data breakpoints.
// To clear all data breakpoints, specify an empty array.
// When a data breakpoint is hit, a 'stopped' event (with reason 'data
// breakpoint') is generated.
struct SetDataBreakpointsRequest : public Request {
  using Response = SetDataBreakpointsResponse;

  SetDataBreakpointsRequest();
  ~SetDataBreakpointsRequest();

  // The contents of this array replaces all existing data breakpoints. An empty
  // array clears all data breakpoints.
  array<DataBreakpoint> breakpoints;
};

DAP_DECLARE_STRUCT_TYPEINFO(SetDataBreakpointsRequest);

// Response to 'setExceptionBreakpoints' request. This is just an
// acknowledgement, so no body field is required.
struct SetExceptionBreakpointsResponse : public Response {
  SetExceptionBreakpointsResponse();
  ~SetExceptionBreakpointsResponse();
};

DAP_DECLARE_STRUCT_TYPEINFO(SetExceptionBreakpointsResponse);

// An ExceptionPathSegment represents a segment in a path that is used to match
// leafs or nodes in a tree of exceptions. If a segment consists of more than
// one name, it matches the names provided if 'negate' is false or missing or it
// matches anything except the names provided if 'negate' is true.
struct ExceptionPathSegment {
  ExceptionPathSegment();
  ~ExceptionPathSegment();

  // Depending on the value of 'negate' the names that should match or not
  // match.
  array<string> names;
  // If false or missing this segment matches the names provided, otherwise it
  // matches anything except the names provided.
  optional<boolean> negate;
};

DAP_DECLARE_STRUCT_TYPEINFO(ExceptionPathSegment);

// An ExceptionOptions assigns configuration options to a set of exceptions.
struct ExceptionOptions {
  ExceptionOptions();
  ~ExceptionOptions();

  // Condition when a thrown exception should result in a break.
  ExceptionBreakMode breakMode;
  // A path that selects a single or multiple exceptions in a tree. If 'path' is
  // missing, the whole tree is selected. By convention the first segment of the
  // path is a category that is used to group exceptions in the UI.
  optional<array<ExceptionPathSegment>> path;
};

DAP_DECLARE_STRUCT_TYPEINFO(ExceptionOptions);

// The request configures the debuggers response to thrown exceptions. If an
// exception is configured to break, a 'stopped' event is fired (with reason
// 'exception').
struct SetExceptionBreakpointsRequest : public Request {
  using Response = SetExceptionBreakpointsResponse;

  SetExceptionBreakpointsRequest();
  ~SetExceptionBreakpointsRequest();

  // Configuration options for selected exceptions.
  optional<array<ExceptionOptions>> exceptionOptions;
  // IDs of checked exception options. The set of IDs is returned via the
  // 'exceptionBreakpointFilters' capability.
  array<string> filters;
};

DAP_DECLARE_STRUCT_TYPEINFO(SetExceptionBreakpointsRequest);

// Response to 'setExpression' request.
struct SetExpressionResponse : public Response {
  SetExpressionResponse();
  ~SetExpressionResponse();

  // The number of indexed child variables.
  // The client can use this optional information to present the variables in a
  // paged UI and fetch them in chunks. The value should be less than or equal
  // to 2147483647 (2^31 - 1).
  optional<integer> indexedVariables;
  // The number of named child variables.
  // The client can use this optional information to present the variables in a
  // paged UI and fetch them in chunks. The value should be less than or equal
  // to 2147483647 (2^31 - 1).
  optional<integer> namedVariables;
  // Properties of a value that can be used to determine how to render the
  // result in the UI.
  optional<VariablePresentationHint> presentationHint;
  // The optional type of the value.
  optional<string> type;
  // The new value of the expression.
  string value;
  // If variablesReference is > 0, the value is structured and its children can
  // be retrieved by passing variablesReference to the VariablesRequest. The
  // value should be less than or equal to 2147483647 (2^31 - 1).
  optional<integer> variablesReference;
};

DAP_DECLARE_STRUCT_TYPEINFO(SetExpressionResponse);

// Evaluates the given 'value' expression and assigns it to the 'expression'
// which must be a modifiable l-value. The expressions have access to any
// variables and arguments that are in scope of the specified frame.
struct SetExpressionRequest : public Request {
  using Response = SetExpressionResponse;

  SetExpressionRequest();
  ~SetExpressionRequest();

  // The l-value expression to assign to.
  string expression;
  // Specifies how the resulting value should be formatted.
  optional<ValueFormat> format;
  // Evaluate the expressions in the scope of this stack frame. If not
  // specified, the expressions are evaluated in the global scope.
  optional<integer> frameId;
  // The value expression to assign to the l-value expression.
  string value;
};

DAP_DECLARE_STRUCT_TYPEINFO(SetExpressionRequest);

// Response to 'setFunctionBreakpoints' request.
// Returned is information about each breakpoint created by this request.
struct SetFunctionBreakpointsResponse : public Response {
  SetFunctionBreakpointsResponse();
  ~SetFunctionBreakpointsResponse();

  // Information about the breakpoints. The array elements correspond to the
  // elements of the 'breakpoints' array.
  array<Breakpoint> breakpoints;
};

DAP_DECLARE_STRUCT_TYPEINFO(SetFunctionBreakpointsResponse);

// Properties of a breakpoint passed to the setFunctionBreakpoints request.
struct FunctionBreakpoint {
  FunctionBreakpoint();
  ~FunctionBreakpoint();

  // An optional expression for conditional breakpoints.
  optional<string> condition;
  // An optional expression that controls how many hits of the breakpoint are
  // ignored. The backend is expected to interpret the expression as needed.
  optional<string> hitCondition;
  // The name of the function.
  string name;
};

DAP_DECLARE_STRUCT_TYPEINFO(FunctionBreakpoint);

// Replaces all existing function breakpoints with new function breakpoints.
// To clear all function breakpoints, specify an empty array.
// When a function breakpoint is hit, a 'stopped' event (with reason 'function
// breakpoint') is generated.
struct SetFunctionBreakpointsRequest : public Request {
  using Response = SetFunctionBreakpointsResponse;

  SetFunctionBreakpointsRequest();
  ~SetFunctionBreakpointsRequest();

  // The function names of the breakpoints.
  array<FunctionBreakpoint> breakpoints;
};

DAP_DECLARE_STRUCT_TYPEINFO(SetFunctionBreakpointsRequest);

// Response to 'setVariable' request.
struct SetVariableResponse : public Response {
  SetVariableResponse();
  ~SetVariableResponse();

  // The number of indexed child variables.
  // The client can use this optional information to present the variables in a
  // paged UI and fetch them in chunks. The value should be less than or equal
  // to 2147483647 (2^31 - 1).
  optional<integer> indexedVariables;
  // The number of named child variables.
  // The client can use this optional information to present the variables in a
  // paged UI and fetch them in chunks. The value should be less than or equal
  // to 2147483647 (2^31 - 1).
  optional<integer> namedVariables;
  // The type of the new value. Typically shown in the UI when hovering over the
  // value.
  optional<string> type;
  // The new value of the variable.
  string value;
  // If variablesReference is > 0, the new value is structured and its children
  // can be retrieved by passing variablesReference to the VariablesRequest. The
  // value should be less than or equal to 2147483647 (2^31 - 1).
  optional<integer> variablesReference;
};

DAP_DECLARE_STRUCT_TYPEINFO(SetVariableResponse);

// Set the variable with the given name in the variable container to a new
// value.
struct SetVariableRequest : public Request {
  using Response = SetVariableResponse;

  SetVariableRequest();
  ~SetVariableRequest();

  // Specifies details on how to format the response value.
  optional<ValueFormat> format;
  // The name of the variable in the container.
  string name;
  // The value of the variable.
  string value;
  // The reference of the variable container.
  integer variablesReference;
};

DAP_DECLARE_STRUCT_TYPEINFO(SetVariableRequest);

// Response to 'source' request.
struct SourceResponse : public Response {
  SourceResponse();
  ~SourceResponse();

  // Content of the source reference.
  string content;
  // Optional content type (mime type) of the source.
  optional<string> mimeType;
};

DAP_DECLARE_STRUCT_TYPEINFO(SourceResponse);

// The request retrieves the source code for a given source reference.
struct SourceRequest : public Request {
  using Response = SourceResponse;

  SourceRequest();
  ~SourceRequest();

  // Specifies the source content to load. Either source.path or
  // source.sourceReference must be specified.
  optional<Source> source;
  // The reference to the source. This is the same as source.sourceReference.
  // This is provided for backward compatibility since old backends do not
  // understand the 'source' attribute.
  integer sourceReference;
};

DAP_DECLARE_STRUCT_TYPEINFO(SourceRequest);

// A Stackframe contains the source location.
struct StackFrame {
  StackFrame();
  ~StackFrame();

  // The column within the line. If source is null or doesn't exist, column is 0
  // and must be ignored.
  integer column;
  // An optional end column of the range covered by the stack frame.
  optional<integer> endColumn;
  // An optional end line of the range covered by the stack frame.
  optional<integer> endLine;
  // An identifier for the stack frame. It must be unique across all threads.
  // This id can be used to retrieve the scopes of the frame with the
  // 'scopesRequest' or to restart the execution of a stackframe.
  integer id;
  // Optional memory reference for the current instruction pointer in this
  // frame.
  optional<string> instructionPointerReference;
  // The line within the file of the frame. If source is null or doesn't exist,
  // line is 0 and must be ignored.
  integer line;
  // The module associated with this frame, if any.
  optional<variant<integer, string>> moduleId;
  // The name of the stack frame, typically a method name.
  string name;
  // An optional hint for how to present this frame in the UI. A value of
  // 'label' can be used to indicate that the frame is an artificial frame that
  // is used as a visual label or separator. A value of 'subtle' can be used to
  // change the appearance of a frame in a 'subtle' way.
  //
  // Must be one of the following enumeration values:
  // 'normal', 'label', 'subtle'
  optional<string> presentationHint;
  // The optional source of the frame.
  optional<Source> source;
};

DAP_DECLARE_STRUCT_TYPEINFO(StackFrame);

// Response to 'stackTrace' request.
struct StackTraceResponse : public Response {
  StackTraceResponse();
  ~StackTraceResponse();

  // The frames of the stackframe. If the array has length zero, there are no
  // stackframes available. This means that there is no location information
  // available.
  array<StackFrame> stackFrames;
  // The total number of frames available.
  optional<integer> totalFrames;
};

DAP_DECLARE_STRUCT_TYPEINFO(StackTraceResponse);

// Provides formatting information for a stack frame.
struct StackFrameFormat : public ValueFormat {
  StackFrameFormat();
  ~StackFrameFormat();

  // Includes all stack frames, including those the debug adapter might
  // otherwise hide.
  optional<boolean> includeAll;
  // Displays the line number of the stack frame.
  optional<boolean> line;
  // Displays the module of the stack frame.
  optional<boolean> module;
  // Displays the names of parameters for the stack frame.
  optional<boolean> parameterNames;
  // Displays the types of parameters for the stack frame.
  optional<boolean> parameterTypes;
  // Displays the values of parameters for the stack frame.
  optional<boolean> parameterValues;
  // Displays parameters for the stack frame.
  optional<boolean> parameters;
};

DAP_DECLARE_STRUCT_TYPEINFO(StackFrameFormat);

// The request returns a stacktrace from the current execution state.
struct StackTraceRequest : public Request {
  using Response = StackTraceResponse;

  StackTraceRequest();
  ~StackTraceRequest();

  // Specifies details on how to format the stack frames.
  optional<StackFrameFormat> format;
  // The maximum number of frames to return. If levels is not specified or 0,
  // all frames are returned.
  optional<integer> levels;
  // The index of the first frame to return; if omitted frames start at 0.
  optional<integer> startFrame;
  // Retrieve the stacktrace for this thread.
  integer threadId;
};

DAP_DECLARE_STRUCT_TYPEINFO(StackTraceRequest);

// Response to 'stepBack' request. This is just an acknowledgement, so no body
// field is required.
struct StepBackResponse : public Response {
  StepBackResponse();
  ~StepBackResponse();
};

DAP_DECLARE_STRUCT_TYPEINFO(StepBackResponse);

// The request starts the debuggee to run one step backwards.
// The debug adapter first sends the response and then a 'stopped' event (with
// reason 'step') after the step has completed. Clients should only call this
// request if the capability 'supportsStepBack' is true.
struct StepBackRequest : public Request {
  using Response = StepBackResponse;

  StepBackRequest();
  ~StepBackRequest();

  // Execute 'stepBack' for this thread.
  integer threadId;
};

DAP_DECLARE_STRUCT_TYPEINFO(StepBackRequest);

// Response to 'stepIn' request. This is just an acknowledgement, so no body
// field is required.
struct StepInResponse : public Response {
  StepInResponse();
  ~StepInResponse();
};

DAP_DECLARE_STRUCT_TYPEINFO(StepInResponse);

// The request starts the debuggee to step into a function/method if possible.
// If it cannot step into a target, 'stepIn' behaves like 'next'.
// The debug adapter first sends the response and then a 'stopped' event (with
// reason 'step') after the step has completed. If there are multiple
// function/method calls (or other targets) on the source line, the optional
// argument 'targetId' can be used to control into which target the 'stepIn'
// should occur. The list of possible targets for a given source line can be
// retrieved via the 'stepInTargets' request.
struct StepInRequest : public Request {
  using Response = StepInResponse;

  StepInRequest();
  ~StepInRequest();

  // Optional id of the target to step into.
  optional<integer> targetId;
  // Execute 'stepIn' for this thread.
  integer threadId;
};

DAP_DECLARE_STRUCT_TYPEINFO(StepInRequest);

// A StepInTarget can be used in the 'stepIn' request and determines into which
// single target the stepIn request should step.
struct StepInTarget {
  StepInTarget();
  ~StepInTarget();

  // Unique identifier for a stepIn target.
  integer id;
  // The name of the stepIn target (shown in the UI).
  string label;
};

DAP_DECLARE_STRUCT_TYPEINFO(StepInTarget);

// Response to 'stepInTargets' request.
struct StepInTargetsResponse : public Response {
  StepInTargetsResponse();
  ~StepInTargetsResponse();

  // The possible stepIn targets of the specified source location.
  array<StepInTarget> targets;
};

DAP_DECLARE_STRUCT_TYPEINFO(StepInTargetsResponse);

// This request retrieves the possible stepIn targets for the specified stack
// frame. These targets can be used in the 'stepIn' request. The StepInTargets
// may only be called if the 'supportsStepInTargetsRequest' capability exists
// and is true.
struct StepInTargetsRequest : public Request {
  using Response = StepInTargetsResponse;

  StepInTargetsRequest();
  ~StepInTargetsRequest();

  // The stack frame for which to retrieve the possible stepIn targets.
  integer frameId;
};

DAP_DECLARE_STRUCT_TYPEINFO(StepInTargetsRequest);

// Response to 'stepOut' request. This is just an acknowledgement, so no body
// field is required.
struct StepOutResponse : public Response {
  StepOutResponse();
  ~StepOutResponse();
};

DAP_DECLARE_STRUCT_TYPEINFO(StepOutResponse);

// The request starts the debuggee to run again for one step.
// The debug adapter first sends the response and then a 'stopped' event (with
// reason 'step') after the step has completed.
struct StepOutRequest : public Request {
  using Response = StepOutResponse;

  StepOutRequest();
  ~StepOutRequest();

  // Execute 'stepOut' for this thread.
  integer threadId;
};

DAP_DECLARE_STRUCT_TYPEINFO(StepOutRequest);

// The event indicates that the execution of the debuggee has stopped due to
// some condition. This can be caused by a break point previously set, a
// stepping action has completed, by executing a debugger statement etc.
struct StoppedEvent : public Event {
  StoppedEvent();
  ~StoppedEvent();

  // If 'allThreadsStopped' is true, a debug adapter can announce that all
  // threads have stopped.
  // - The client should use this information to enable that all threads can be
  // expanded to access their stacktraces.
  // - If the attribute is missing or false, only the thread with the given
  // threadId can be expanded.
  optional<boolean> allThreadsStopped;
  // The full reason for the event, e.g. 'Paused on exception'. This string is
  // shown in the UI as is and must be translated.
  optional<string> description;
  // A value of true hints to the frontend that this event should not change the
  // focus.
  optional<boolean> preserveFocusHint;
  // The reason for the event.
  // For backward compatibility this string is shown in the UI if the
  // 'description' attribute is missing (but it must not be translated).
  //
  // May be one of the following enumeration values:
  // 'step', 'breakpoint', 'exception', 'pause', 'entry', 'goto', 'function
  // breakpoint', 'data breakpoint'
  string reason;
  // Additional information. E.g. if reason is 'exception', text contains the
  // exception name. This string is shown in the UI.
  optional<string> text;
  // The thread which was stopped.
  optional<integer> threadId;
};

DAP_DECLARE_STRUCT_TYPEINFO(StoppedEvent);

// Response to 'terminate' request. This is just an acknowledgement, so no body
// field is required.
struct TerminateResponse : public Response {
  TerminateResponse();
  ~TerminateResponse();
};

DAP_DECLARE_STRUCT_TYPEINFO(TerminateResponse);

// The 'terminate' request is sent from the client to the debug adapter in order
// to give the debuggee a chance for terminating itself.
struct TerminateRequest : public Request {
  using Response = TerminateResponse;

  TerminateRequest();
  ~TerminateRequest();

  // A value of true indicates that this 'terminate' request is part of a
  // restart sequence.
  optional<boolean> restart;
};

DAP_DECLARE_STRUCT_TYPEINFO(TerminateRequest);

// Response to 'terminateThreads' request. This is just an acknowledgement, so
// no body field is required.
struct TerminateThreadsResponse : public Response {
  TerminateThreadsResponse();
  ~TerminateThreadsResponse();
};

DAP_DECLARE_STRUCT_TYPEINFO(TerminateThreadsResponse);

// The request terminates the threads with the given ids.
struct TerminateThreadsRequest : public Request {
  using Response = TerminateThreadsResponse;

  TerminateThreadsRequest();
  ~TerminateThreadsRequest();

  // Ids of threads to be terminated.
  optional<array<integer>> threadIds;
};

DAP_DECLARE_STRUCT_TYPEINFO(TerminateThreadsRequest);

// The event indicates that debugging of the debuggee has terminated. This does
// **not** mean that the debuggee itself has exited.
struct TerminatedEvent : public Event {
  TerminatedEvent();
  ~TerminatedEvent();

  // A debug adapter may set 'restart' to true (or to an arbitrary object) to
  // request that the front end restarts the session. The value is not
  // interpreted by the client and passed unmodified as an attribute '__restart'
  // to the 'launch' and 'attach' requests.
  optional<variant<array<any>, boolean, integer, null, number, object, string>>
      restart;
};

DAP_DECLARE_STRUCT_TYPEINFO(TerminatedEvent);

// The event indicates that a thread has started or exited.
struct ThreadEvent : public Event {
  ThreadEvent();
  ~ThreadEvent();

  // The reason for the event.
  //
  // May be one of the following enumeration values:
  // 'started', 'exited'
  string reason;
  // The identifier of the thread.
  integer threadId;
};

DAP_DECLARE_STRUCT_TYPEINFO(ThreadEvent);

// A Thread
struct Thread {
  Thread();
  ~Thread();

  // Unique identifier for the thread.
  integer id;
  // A name of the thread.
  string name;
};

DAP_DECLARE_STRUCT_TYPEINFO(Thread);

// Response to 'threads' request.
struct ThreadsResponse : public Response {
  ThreadsResponse();
  ~ThreadsResponse();

  // All threads.
  array<Thread> threads;
};

DAP_DECLARE_STRUCT_TYPEINFO(ThreadsResponse);

// The request retrieves a list of all threads.
struct ThreadsRequest : public Request {
  using Response = ThreadsResponse;

  ThreadsRequest();
  ~ThreadsRequest();
};

DAP_DECLARE_STRUCT_TYPEINFO(ThreadsRequest);

// A Variable is a name/value pair.
// Optionally a variable can have a 'type' that is shown if space permits or
// when hovering over the variable's name. An optional 'kind' is used to render
// additional properties of the variable, e.g. different icons can be used to
// indicate that a variable is public or private. If the value is structured
// (has children), a handle is provided to retrieve the children with the
// VariablesRequest. If the number of named or indexed children is large, the
// numbers should be returned via the optional 'namedVariables' and
// 'indexedVariables' attributes. The client can use this optional information
// to present the children in a paged UI and fetch them in chunks.
struct Variable {
  Variable();
  ~Variable();

  // Optional evaluatable name of this variable which can be passed to the
  // 'EvaluateRequest' to fetch the variable's value.
  optional<string> evaluateName;
  // The number of indexed child variables.
  // The client can use this optional information to present the children in a
  // paged UI and fetch them in chunks.
  optional<integer> indexedVariables;
  // Optional memory reference for the variable if the variable represents
  // executable code, such as a function pointer.
  optional<string> memoryReference;
  // The variable's name.
  string name;
  // The number of named child variables.
  // The client can use this optional information to present the children in a
  // paged UI and fetch them in chunks.
  optional<integer> namedVariables;
  // Properties of a variable that can be used to determine how to render the
  // variable in the UI.
  optional<VariablePresentationHint> presentationHint;
  // The type of the variable's value. Typically shown in the UI when hovering
  // over the value.
  optional<string> type;
  // The variable's value. This can be a multi-line text, e.g. for a function
  // the body of a function.
  string value;
  // If variablesReference is > 0, the variable is structured and its children
  // can be retrieved by passing variablesReference to the VariablesRequest.
  integer variablesReference;
};

DAP_DECLARE_STRUCT_TYPEINFO(Variable);

// Response to 'variables' request.
struct VariablesResponse : public Response {
  VariablesResponse();
  ~VariablesResponse();

  // All (or a range) of variables for the given variable reference.
  array<Variable> variables;
};

DAP_DECLARE_STRUCT_TYPEINFO(VariablesResponse);

// Retrieves all child variables for the given variable reference.
// An optional filter can be used to limit the fetched children to either named
// or indexed children.
struct VariablesRequest : public Request {
  using Response = VariablesResponse;

  VariablesRequest();
  ~VariablesRequest();

  // The number of variables to return. If count is missing or 0, all variables
  // are returned.
  optional<integer> count;
  // Optional filter to limit the child variables to either named or indexed. If
  // omitted, both types are fetched.
  //
  // Must be one of the following enumeration values:
  // 'indexed', 'named'
  optional<string> filter;
  // Specifies details on how to format the Variable values.
  optional<ValueFormat> format;
  // The index of the first variable to return; if omitted children start at 0.
  optional<integer> start;
  // The Variable reference.
  integer variablesReference;
};

DAP_DECLARE_STRUCT_TYPEINFO(VariablesRequest);

}  // namespace dap

#endif  // dap_protocol_h
